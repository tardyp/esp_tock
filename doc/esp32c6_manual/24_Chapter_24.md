---
chapter: 24
title: "Chapter 24"
document: "ESP32-C6 Technical Reference Manual"
version: "v1.1"
type: "reference"
source: "docling-pdf-to-markdown"
device: "ESP32-C6"
manufacturer: "Espressif"
---
## Chapter 24

## Digital Signature (DS)

## 24.1 Overview

A Digital Signature (DS) is used to verify the authenticity and integrity of a message using a cryptographic algorithm. This can be used to validate a device's identity to a server, or to check the integrity of a message.

ESP32-C6 includes a Digital Signature (DS) module providing hardware acceleration of messages' signatures based on RSA. HMAC is used as the key derivation function to output the DS\_KEY key using eFuse as the input key. Subsequently, the DS module uses DS\_KEY to decrypt the pre-encrypted parameters and calculate the signature. The whole process happens in hardware so that neither the decryption key for the RSA parameters nor the input key for the HMAC key derivation function can be seen by users while calculating the signature.

## 24.2 Features

- RSA digital signatures with key length up to 3072 bits
- Encrypted private key data, only decryptable by DS module
- SHA-256 digest to protect private key data against tampering by an attacker

## 24.3 Functional Description

## 24.3.1 Overview

The DS peripheral calculates RSA signatures as Z = X Y mod M, where Z is the signature, X is the input message, and Y and M are the RSA private key parameters.

Private key parameters are stored in flash as ciphertext. They are decrypted using a key (DS \_ KEY ) which can only be calculated by the DS peripheral via the HMAC peripheral. The required inputs (HMAC \_ KEY ) to generate the key are only stored in eFuse and can only be accessed by the HMAC peripheral. That is to say, the DS peripheral hardware can decrypt the private key, and the private key in plaintext is never accessed by the software. For more detailed information about eFuse and HMAC peripherals, please refer to Chapter 6 eFuse Controller and 21 HMAC Accelerator (HMAC) peripheral.

The input message X will be sent directly to the DS peripheral by the software each time a signature is needed. After the RSA signature operation, the signature Z is read back by the software.

For better understanding, we define some symbols and functions here, which are only applicable to this chapter:

- 1 s A bit string consisting of s bits with the value of "1".
- [x] s A bit string of s bits, in which s is an integer multiple of 8 bits. If x is a number (x &lt; 2 s ), it is represented in little endian byte order in the bit string. x may be a variable such as [Y ]4096 or a hexadecimal constant such as [0x0C]8. If necessary, the value [x]t can be right-padded with (s − t) number of zeros to reach s bits in length, and finally get [x] s . For example, [0x05]8 = 00000101 , [0x05]16 = 0000010100000000, [0x0005]16 = 0000000000000101, [0x13]8 = 00010011 , [0x13]16 = 0001001100000000, [0x0013]16 = 0000000000010011 .
- || A bit string concatenation operator for joining multiple bit strings into a longer bit string.

## 24.3.2 Private Key Operands

Private key operands Y (private key exponent) and M (key modulus) are generated by the user. They have a particular RSA key length (up to 3072 bits). Two additional private key operands are needed: r and M ′ . These two operands are derived from Y and M .

Operands Y , M , r , and M ′ are encrypted by the user along with an authentication digest and stored as a single ciphertext C . C is input to the DS peripheral in this encrypted format, decrypted by the hardware, and then used for RSA signature calculation. Detailed description of how to generate C is provided in Section 24.3.3 .

The DS peripheral supports RSA signature calculation Z = X Y mod M, in which the length of operands should be N = 32 × x where x ∈ {1 , 2 , 3 , . . . , 96}. The bit lengths of arguments Z , X , Y , M, and r should be an arbitrary value in N, and all of them in a calculation must be of the same length, while the bit length of M ′ should always be 32. For more detailed information about RSA calculation, please refer to Section 22.3.1 Large-number Modular Exponentiation in Chapter 22 RSA Accelerator (RSA) .

## 24.3.3 Software Prerequisites

If users want to use the DS module, the software needs to do a series of preparations, as shown in Figure 24.3-1. The left side lists preparations required by the software before the hardware starts RSA signature calculation, while the right side lists the hardware workflow during the entire calculation procedure.

## Note:

1. The software preparation (left side in the Figure 24.3-1) is a one-time operation before any signature is calculated, while the hardware calculation (right side in the Figure 24.3-1) repeats for every signature calculation.

Users need to follow the steps shown in the left part of Figure 24.3-1 to calculate C. Detailed instructions are as follows:

- Step 1: Prepare operands Y and M whose lengths should meet the requirements in Section 24.3.2 . Define [L]32 = N 32 − 1 (i.e., for RSA 3072, [L]32 == [0x60-1]32). Prepare [HMAC \_ KEY ]256 and calculate [DS \_ KEY ]256 based on DS \_ KEY = HMAC-SHA256 ([HMAC \_ KEY ]256 , 1 256 ). Generate a random [IV ]128 which should meet the requirements of the AES-CBC block encryption algorithm. For more information on AES, please refer to Chapter 19 AES Accelerator (AES) .
- Step 2: Calculate r and M ′ based on M .
- Step 3: Extend Y , M, and r, in order to get [Y ]3072 , [M]3072, and [r]3072, respectively. This step is only required for Y , M, and r whose length are less than 3072 bits, since their largest length are 3072 bits.
- Step 4: Calculate MD authentication code using the SHA-256: [MD]256 = SHA256 ([Y ]3072||[M]3072||[r]3072||[M ′ ]32||[L]32||[IV ]128)
- Step 5: Build [P]9600 = ( [Y ]3072||[M]3072||[r]3072||[Box]384), where [Box]384 = ( [MD]256||[M ′ ]32||[L]32||[β]64) and [β]64 is a PKCS#7 padding value, i.e., a [0x0808080808080808]64 string composed of 8 bytes (0x80). The purpose of [β]64 is to make the bit length of P a multiple of 128.
- Step 6: Calculate C = [C]9600 = AES-CBC-ENC ([P]9600 , [DS \_ KEY ]256 , [IV ]128), where C is the ciphertext with a length of 1200 bytes. C can also be calculated as C = [C]9600 = ([Y b ]3072||[M c ]3072||[ b r ]3072||[Box d ]384), where [Y b ]3072 , [M c ]3072 , [ b r ]3072 , [Box d ]384 are the four sub-parameters of C, and correspond to the ciphertext of [Y ]3072 , [M]3072 , [r]3072 , [Box]384 respectively.

Figure 24.3-1. Software Preparations and Hardware Working Process

![Image](images/24_Chapter_24_img001_6a3ade38.png)

## 24.3.4 DS Operation at the Hardware Level

The hardware operation is triggered each time a digital signature needs to be calculated. The inputs are the pre-generated private key ciphertext C, a unique message X, and IV .

The DS operation at the hardware level can be divided into the following three stages:

## 1. Decryption: Step 7 and 8 in Figure 24.3-1

The decryption process is the inverse of Step 6 in figure 24.3-1. The DS module will call the AES accelerator to decrypt C in CBC block mode and get the resulting plaintext. The decryption process can be represented by P = AES-CBC-DEC (C , DS \_ KEY , IV ), where IV (i.e., [IV ]128) is defined by the user. [DS \_ KEY ]256 is provided by the HMAC module, derived from HMAC \_ KEY stored in eFuse. [DS \_ KEY ]256, as well as [HMAC \_ KEY ]256 are not readable by users. For more information, please refer to Chapter 21HMAC Accelerator (HMAC) .

With P, the DS module can derive [Y ]3072 , [M]3072 , [r]3072 , [M ′ ]32 , [L]32, MD authentication code, and the padding value [β]64. This process is the inverse of Step 5.

## 2. Check: Step 9 and 10 in Figure 24.3-1

The DS module will perform two checks: MD check and padding check. Padding check is not shown in Figure 24.3-1, as it happens at the same time as MD check.

- MD check: The DS module calls SHA-256 to calculate the hash value [CALC \_ MD]256 ([CALC \_ MD]256 is calculated the same way and with same parameters as [MD]256, see step 4). Then, [CALC \_ MD]256 is compared against the MD authentication code [MD]256 from step 4. Only when the two match does the MD check pass.
- Padding check: The DS module checks if [β]64 complies with the aforementioned PKCS#7 format. Only when [β]64 complies with the format does the padding check pass.

The DS module will only perform subsequent operations if MD check passes. If padding check fails, a warning is generated, but it does not affect the subsequent operations.

## 3. Calculation: Step 11 and 12 in Figure 24.3-1

The DS module treats X (input by the user) and Y , M , r (decrypted in step 8) as big numbers. With M ′ , all operands to perform X Y mod M are in place. The operand length is defined by L only. The DS module will calculate the signed result Z by calling RSA to perform Z = X Y mod M .

## 24.3.5 DS Operation at the Software Level

The software steps below should be followed each time a digital signature needs to be calculated. The inputs are the pre-generated private key ciphertext C, a unique message X, and IV . These software steps trigger the hardware steps described in Section 24.3.4 .

We assume that the software has called the HMAC peripheral and the HMAC peripheral has calculated DS \_ KEY based on HMAC \_ KEY .

1. Prerequisites: Prepare operands C , X , IV according to Section 24.3.3 .
2. Activate the DS peripheral: Write 1 to DS\_SET\_START\_REG .
3. Check if DS \_ KEY is ready: Poll DS\_QUERY\_BUSY\_REG until the software reads 0.

![Image](images/24_Chapter_24_img002_d5b7ee3f.png)

If the software does not read 0 in DS\_QUERY\_BUSY\_REG after approximately 1 ms, it indicates a problem with HMAC initialization. In such a case, the software can read register DS\_QUERY\_KEY\_WRONG\_REG to get more information:

- If the software reads 0 in DS\_QUERY\_KEY\_WRONG\_REG, it indicates that the HMAC peripheral has not been called.
- If the software reads any value from 1 to 15 in DS\_QUERY\_KEY\_WRONG\_REG, it indicates that HMAC was called, but the DS module did not successfully get the DS \_ KEY value from the HMAC peripheral. This may indicate that the HMAC operation has been interrupted due to a software concurrency problem.
4. Configure register: Write IV block to register DS\_IV\_m\_REG (m: 0 ~ 3). For more information on the IV block, please refer to Chapter 19 AES Accelerator (AES) .
5. Write X to memory block DS\_X\_MEM: Write Xi (i ∈ {0 , 1, . . . , n − 1}), where n = N 32 , to memory block DS\_X\_MEM whose capacity is 96 words. Each word can store one base-b digit. The memory block uses the little endian format for storage, i.e., the least significant digit of the operand is in the lowest address. Words in DS\_X\_MEM block after the configured length of X (N bits, as described in Section 24.3.2), are ignored.
6. Write C to corresponding memory blocks: Write the four sub-parameters of C to corresponding memory blocks:
- Write Y
- Write M
- Write b ri (i ∈ {0 , 1 , . . . , 95}) to DS\_RB\_MEM .
- write Box d i (i ∈ {0 , 1 , . . . , 11}) to DS\_BOX\_MEM .

The capacity of DS\_Y\_MEM , DS\_M\_MEM, and DS\_RB\_MEM is 96 words, whereas the capacity of DS\_BOX\_MEM is only 12 words. Each word can store one base-b digit. The memory blocks use the little endian format for storage, i.e., the least significant digit of the operand is in the lowest address.

7. Start DS operation: Write 1 to register DS\_SET\_ME\_REG .
8. Wait for the operation to be completed: Poll register DS\_QUERY\_BUSY\_REG until the software reads 0.
9. Query check result: Read register DS\_QUERY\_CHECK\_REG and conduct subsequent operations as illustrated below based on the return value:
- If the value is 0, it indicates that both padding check and MD check pass. Users can continue to get the signed result Z .
- If the value is 1, it indicates that the padding check passes but MD check fails. The signed result Z is invalid. The operation will resume directly from Step 11 .
- If the value is 2, it indicates that the padding check fails but MD check passes. Users can continue to get the signed result Z. But please note that the data does not comply with the aforementioned PKCS#7 padding format, which may not be what you want.
- If the value is 3, it indicates that both padding check and MD check fail. In this case, some fatal errors have occurred and the signed result Z is invalid. The operation will resume directly from Step 11 .

![Image](images/24_Chapter_24_img003_f3573160.png)

10. Read the signed result: Read the signed result Zi (i ∈ {0 , 1, . . . , n − 1}), where n = N 32 , from memory block DS\_Z\_MEM. The memory block stores Z in little-endian byte order.
11. Exit the operation: Write 1 to DS\_SET\_FINISH\_REG, and then poll DS\_QUERY\_BUSY\_REG until the software reads 0.

After the operation, all the input/output registers and memory blocks are cleared.

## 24.4 Memory Summary

The addresses in this section are relative to the Digital Signature base address provided in Table 5.3-2 in Chapter 5 System and Memory .

| Name       | Description      |   Size (byte) | Starting Address   | Ending Address   | Access   |
|------------|------------------|---------------|--------------------|------------------|----------|
| DS_Y_MEM   | Memory block Y   |           384 | 0x0000             | 0x017F           | WO       |
| DS_M_MEM   | Memory block M   |           384 | 0x0200             | 0x037F           | WO       |
| DS_RB_MEM  | Memory block r   |           384 | 0x0400             | 0x057F           | WO       |
| DS_BOX_MEM | Memory block Box |            48 | 0x0600             | 0x062F           | WO       |
| DS_X_MEM   | Memory block X   |           384 | 0x0800             | 0x097F           | WO       |
| DS_Z_MEM   | Memory block Z   |           384 | 0x0A00             | 0x0B7F           | RO       |

## 24.5 Register Summary

The addresses in this section are relative to Digital Signature base address provided in Table 5.3-2 in Chapter 5 System and Memory .

The abbreviations given in Column Access are explained in Section Access Types for Registers .

| Name                     | Description                                 | Address                  | Access                   |
|--------------------------|---------------------------------------------|--------------------------|--------------------------|
| Configuration Registers  | Configuration Registers                     | Configuration Registers  | Configuration Registers  |
| DS_IV_0_REG              | IV block data                               | 0x0630                   | WO                       |
| DS_IV_1_REG              | IV block data                               | 0x0634                   | WO                       |
| DS_IV_2_REG              | IV block data                               | 0x0638                   | WO                       |
| DS_IV_3_REG              | IV block data                               | 0x063C                   | WO                       |
| Status/Control Registers | Status/Control Registers                    | Status/Control Registers | Status/Control Registers |
| DS_SET_START_REG         | Activates the DS module                     | 0x0E00                   | WO                       |
| DS_SET_ME_REG            | Starts DS operation                         | 0x0E04                   | WO                       |
| DS_SET_FINISH_REG        | Ends DS operation                           | 0x0E08                   | WO                       |
| DS_QUERY_BUSY_REG        | Status of the DS module                     | 0x0E0C                   | RO                       |
| DS_QUERY_KEY_WRONG_REG   | Checks the reason why DS _ KEY is not ready | 0x0E10                   | RO                       |
| DS_QUERY_CHECK_REG       | Queries DS check result                     | 0x0E14                   | RO                       |
| Version control register | Version control register                    | Version control register | Version control register |
| DS_DATE_REG              | Version control register                    | 0x0E20                   | W/R                      |

## 24.6 Registers

The addresses in this section are relative to Digital Signature base address provided in Table 5.3-2 in Chapter 5 System and Memory .

Register 24.1. DS\_IV\_m\_REG (m: 0-3) (0x0630+4*n)

![Image](images/24_Chapter_24_img004_028692f3.png)

DS\_IV\_m\_REG Writes IV block data. (WO)

Register 24.2. DS\_SET\_START\_REG (0x0E00)

![Image](images/24_Chapter_24_img005_712dbf8b.png)

DS\_SET\_START Configures whether or not to activate the DS peripheral.

- 0: Invalid
- 1: Activate the DS peripheral

(WO)

Register 24.3. DS\_SET\_ME\_REG (0x0E04)

![Image](images/24_Chapter_24_img006_5c89dcf3.png)

DS\_SET\_ME Configures whether or not to start DS operation.

- 0: Invalid
- 1: Start DS operation

(WO)

Register 24.4. DS\_SET\_FINISH\_REG (0x0E08)

![Image](images/24_Chapter_24_img007_e6ea77cf.png)

- DS\_SET\_FINISH Configures whether or not to end DS operation.
- 0: Invalid
- 1: End DS operation

(WO)

Register 24.5. DS\_QUERY\_BUSY\_REG (0x0E0C)

![Image](images/24_Chapter_24_img008_34b2910f.png)

- DS\_QUERY\_BUSY Represents whether or not the DS module is idle.
- 0: The DS module is idle
- 1: The DS module is busy (RO)
- DS\_QUERY\_KEY\_WRONG Represents the specific problem with HMAC initialization.
- 0: HMAC is not called

Register 24.6. DS\_QUERY\_KEY\_WRONG\_REG (0x0E10)

![Image](images/24_Chapter_24_img009_11a14840.png)

1-15: HMAC was activated, but the DS peripheral did not successfully receive the DS

from the HMAC peripheral. (The biggest value is 15)

(RO)

\_

KEY

## Register 24.7. DS\_QUERY\_CHECK\_REG (0x0E14)

![Image](images/24_Chapter_24_img010_e64bf03e.png)

- DS\_PADDING\_BAD Represents whether or not the padding check passes.
- 0: The padding check passes
- 1: The padding check fails

(RO)

- DS\_MD\_ERROR Represents whether or not the MD check passes.
- 0: The MD check passes
- 1: The MD check fails

(RO)

## Register 24.8. DS\_DATE\_REG (0x0E20)

![Image](images/24_Chapter_24_img011_95ff5d3a.png)

DS\_DATE Version control register. (R/W)
