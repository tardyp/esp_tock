---
chapter: 22
title: "Chapter 22"
document: "ESP32-C3 Technical Reference Manual"
version: "v1.3"
type: "reference"
source: "docling-pdf-to-markdown"
device: "ESP32-C3"
manufacturer: "Espressif"
---
## Chapter 22

## Digital Signature (DS)

## 22.1 Overview

A Digital Signature is used to verify the authenticity and integrity of a message using a cryptographic algorithm. This can be used to validate a device's identity to a server, or to check the integrity of a message.

The ESP32-C3 includes a Digital Signature (DS) module providing hardware acceleration of messages' signatures based on RSA. It uses pre-encrypted parameters to calculate a signature. The parameters are encrypted using HMAC as a key-derivation function. In turn, the HMAC uses eFuses as an input key. The whole process happens in hardware so that neither the decryption key for the RSA parameters nor the input key for the HMAC key derivation function can be seen by users while calculating the signature.

## 22.2 Features

- RSA digital signatures with key length up to 3072 bits
- Encrypted private key data, only decryptable by DS module
- SHA-256 digest to protect private key data against tampering by an attacker

## 22.3 Functional Description

## 22.3.1 Overview

The DS peripheral calculates RSA signature as Z = X Y mod M where Z is the signature, X is the input message, and Y and M are the RSA private key parameters.

Private key parameters are stored in flash as ciphertext. They are decrypted using a key (DS \_ KEY ) which can only be calculated by the DS peripheral via the HMAC peripheral. The required inputs (HMAC \_ KEY ) to generate the key are only stored in eFuse and can only be accessed by the HMAC peripheral. That is to say, the DS peripheral hardware can decrypt the private key, and the private key in plaintext is never accessed by the software. For more detailed information about eFuse and HMAC peripherals, please refer to Chapter 4 eFuse Controller (EFUSE) and 19 HMAC Accelerator (HMAC) peripheral.

The input message X will be sent directly to the DS peripheral by the software each time a signature is needed. After the RSA signature operation, the signature Z is read back by the software.

For better understanding, we define some symbols and functions here, which are only applicable to this chapter:

- 1 s A bit string consist of s bits with the value of "1".

- [x] s A bit string of s bits, in which s should be an integer multiple of 8 bits. If x is a number (x &lt; 2 s ), it is represented in little endian byte order in the bit string. x may be a variable such as [Y ]4096 or as a hexadecimal constant such as [0x0C]8. If necessary, the value [x]t can be right-padded with (s − t) number of 0 to reach s bits in length, and finally get [x] s . For example, [0x05]8 = 00000101 , [0x05]16 = 0000010100000000, [0x0005]16 = 0000000000000101, [0x13]8 = 00010011 , [0x13]16 = 0001001100000000, [0x0013]16 = 0000000000010011 .
- || A bit string concatenation operator for joining multiple bit strings into a longer bit string.

## 22.3.2 Private Key Operands

Private key operands Y (private key exponent) and M (key modulus) are generated by you. They have a particular RSA key length (up to 3072 bits). Two additional private key operands are needed: r and M ′ . These two operands are derived from Y and M .

Operands Y , M , r and M ′ are encrypted by you along with an authentication digest and stored as a single ciphertext C . C is input to the DS peripheral in this encrypted format, decrypted by the hardware, and then used for RSA signature calculation. Detailed description of how to generate C is provided in Section 22.3.3 .

The DS peripheral supports RSA signature calculation Z = X Y mod M, in which the length of operands should be N = 32 × x where x ∈ {1 , 2 , 3 , . . . , 96}. The bit lengths of arguments Z , X , Y , M and r should be an arbitrary value in N, and all of them in a calculation must be of the same length, while the bit length of M ′ should always be 32. For more detailed information about RSA calculation, please refer to Section 20.3.1 Large Number Modular Exponentiation in Chapter 20 RSA Accelerator (RSA) .

## 22.3.3 Software Prerequisites

If users want to use the DS module for digital signature, the software and hardware must work closely to implement this successfully, and the software needs to do a series of preparations, as shown in Figure 22.3-1 . The left side lists preparations required by the software before the hardware starts RSA signature calculation, while the right side lists the hardware workflow during the entire calculation procedure.

## Note:

1. The software preparation (left side in the Figure 22.3-1) is a one-time operation before any signature is calculated, while the hardware calculation (right side in the Figure 22.3-1) repeats for every signature calculation.

You need to follow the steps shown in the left part of Figure 22.3-1 to calculate C. Detailed instructions are as follows:

- Step 1: Prepare operands Y and M whose lengths should meet the requirements in Section 22.3.2 . Define [L]32 = N 32 − 1 (i.e., for RSA 3072, [L]32 == [0x60-1]32). Prepare [HMAC \_ KEY ]256 and calculate [DS \_ KEY ]256 based on DS \_ KEY = HMAC-SHA256 ([HMAC \_ KEY ]256 , 1 256 ). Generate a random [IV ]128 which should meet the requirements of the AES-CBC block encryption algorithm. For more information on AES, please refer to Chapter 18 AES Accelerator (AES) .
- Step 2: Calculate r and M ′ based on M .
- Step 3: Extend Y , M and r, in order to get [Y ]3072 , [M]3072 and [r]3072, respectively. This step is only required for Y , M and r whose length are less than 3072 bits, since their largest length are 3072 bits.
- Step 4: Calculate MD authentication code using the SHA-256: [MD]256 = SHA256 ([Y ]3072||[M]3072||[r]3072||[M ′ ]32||[L]32||[IV ]128)
- Step 5: Build [P]9600 = ( [Y ]3072||[M]3072||[r]3072||[Box]384), where [Box]384 = ( [MD]256||[M ′ ]32||[L]32||[β]64) and [β]64 is a PKCS#7 padding value, i.e., a [0x0808080808080808]64 string composed of 8 bytes (0x80). The purpose of [β]64 is to make the bit length of P a multiple of 128.
- Step 6: Calculate C = [C]9600 = AES-CBC-ENC ([P]9600 , [DS \_ KEY ]256 , [IV ]128), where C is the ciphertext with a length of 1200 bytes. C can also be calculated as C = [C]9600 = ([Y b ]3072||[M c ]3072||[ b r ]3072||[Box d ]384), where [Y b ]3072 , [M c ]3072 , [ b r ]3072 , [Box d ]384 are the four sub-parameters of C, and correspond to the ciphertext of [Y ]3072 , [M]3072 , [r]3072 , [Box]384 respectively.

Figure 22.3-1. Software Preparations and Hardware Working Process

![Image](images/22_Chapter_22_img001_6a3ade38.png)

## 22.3.4 DS Operation at the Hardware Level

The hardware operation is triggered each time a digital signature needs to be calculated. The inputs are the pre-generated private key ciphertext C, a unique message X, and IV .

The DS operation at the hardware level can be divided into the following three stages:

## 1. Decryption: Step 7 and 8 in Figure 22.3-1

The decryption process is the inverse of Step 6 in figure 22.3-1. The DS module will call AES accelerator to decrypt C in CBC block mode and get the resulted plaintext. The decryption process can be represented by P = AES-CBC-DEC (C , DS \_ KEY , IV ), where IV (i.e., [IV ]128) is defined by you. [DS \_ KEY ]256 is provided by HMAC module, derived from HMAC \_ KEY stored in eFuse. [DS \_ KEY ]256, as well as [HMAC \_ KEY ]256 are not readable by users. For more information, please refer to Chapter 19HMAC Accelerator (HMAC) .

With P, the DS module can derive [Y ]3072 , [M]3072 , [r]3072 , [M ′ ]32 , [L]32, MD authentication code, and the padding value [β]64. This process is the inverse of Step 5.

## 2. Check: Step 9 and 10 in Figure 22.3-1

The DS module will perform two checks: MD check and padding check. Padding check is not shown in Figure 22.3-1, as it happens at the same time with MD check.

- MD check: The DS module calls SHA-256 to calculate the hash value [CALC \_ MD]256 (i.e., step 4). Then, [CALC \_ MD]256 is compared against the MD authentication code [MD]256 from step 4. Only when the two match does the MD check pass.
- Padding check: The DS module checks if [β]64 complies with the aforementioned PKCS#7 format. Only when [β]64 complies with the format does the padding check pass.

The DS module will only perform subsequent operations if MD check passes. If padding check fails, a warning message is generated, but it does not affect the subsequent operations.

## 3. Calculation: Step 11 and 12 in Figure 22.3-1

The DS module treats X (input by you) and Y , M , r (compiled) as big numbers. With M ′ , all operands to perform X Y mod M are in place. The operand length is defined by L only. The DS module will get the signed result Z by calling RSA to perform Z = X Y mod M .

## 22.3.5 DS Operation at the Software Level

The software steps below should be followed each time a digital signature needs to be calculated. The inputs are the pre-generated private key ciphertext C, a unique message X, and IV . These software steps trigger the hardware steps described in Section 22.3.4 .

We assume that the software has called the HMAC peripheral and HMAC on the hardware has calculated DS \_ KEY based on HMAC \_ KEY .

1. Prerequisites: Prepare operands C , X , IV according to Section 22.3.3 .
2. Activate the DS peripheral: Write 1 to DS\_SET\_START\_REG .
3. Check if DS \_ KEY is ready: Poll DS\_QUERY\_BUSY\_REG until the software reads 0.

If the software does not read 0 in DS\_QUERY\_BUSY\_REG after approximately 1 ms, it indicates a problem with HMAC initialization. In such a case, the software can read register DS\_QUERY\_KEY\_WRONG\_REG to get more information:

- If the software reads 0 in DS\_QUERY\_KEY\_WRONG\_REG, it indicates that the HMAC peripheral has not been called.
- If the software reads any value from 1 to 15 in DS\_QUERY\_KEY\_WRONG\_REG, it indicates that HMAC was called, but the DS module did not successfully get the DS \_ KEY value from the HMAC peripheral. This may indicate that the HMAC operation has been interrupted due to a software concurrency problem.
4. Configure register: Write IV block to register DS\_IV\_m\_REG (m: 0 ~ 3). For more information on the IV block, please refer to Chapter 18 AES Accelerator (AES) .
5. Write X to memory block DS\_X\_MEM: Write Xi (i ∈ {0 , 1, . . . , n − 1}), where n = N 32 , to memory block DS\_X\_MEM whose capacity is 96 words. Each word can store one base-b digit. The memory block uses the little endian format for storage, i.e., the least significant digit of the operand is in the lowest address. Words in DS\_X\_MEM block after the configured length of X (N bits, as described in Section 22.3.2), are ignored.
6. Write C to corresponding memory blocks: Write the four sub-parameters of C to corresponding memory blocks:
- Write Y
- Write M
- Write b ri (i ∈ {0 , 1 , . . . , 95}) to DS\_RB\_MEM .
- write Box d i (i ∈ {0 , 1 , . . . , 11}) to DS\_BOX\_MEM .

The capacity of DS\_Y\_MEM , DS\_M\_MEM, and DS\_RB\_MEM is 96 words, whereas the capacity of DS\_BOX\_MEM is only 12 words. Each word can store one base-b digit. The memory blocks use the little endian format for storage, i.e., the least significant digit of the operand is in the lowest address.

7. Start DS operation: Write 1 to register DS\_SET\_ME\_REG .
8. Wait for the operation to be completed: Poll register DS\_QUERY\_BUSY\_REG until the software reads 0.
9. Query check result: Read register DS\_QUERY\_CHECK\_REG and conduct subsequent operations as illustrated below based on the return value:
- If the value is 0, it indicates that both padding check and MD check pass. You can continue to get the signed result Z .
- If the value is 1, it indicates that the padding check passes but MD check fails. The signed result Z is invalid. The operation will resume directly from Step 11 .
- If the value is 2, it indicates that the padding check fails but MD check passes. You can continue to get the signed result Z. But please note that the data does not comply with the aforementioned PKCS#7 padding format, which may not be what you want.
- If the value is 3, it indicates that both padding check and MD check fail. In this case, some fatal errors have occurred and the signed result Z is invalid. The operation will resume directly from Step 11 .

![Image](images/22_Chapter_22_img002_0f0d80bc.png)

10. Read the signed result: Read the signed result Zi (i ∈ {0 , 1, . . . , n − 1}), where n = N 32 , from memory block DS\_Z\_MEM. The memory block stores Z in little-endian byte order.
11. Exit the operation: Write 1 to DS\_SET\_FINISH\_REG, and then poll DS\_QUERY\_BUSY\_REG until the software reads 0.

After the operation, all the input/output registers and memory blocks are cleared.

## 22.4 Memory Summary

The addresses in this section are relative to the Digital Signature base address provided in Table 3.3-3 in Chapter 3 System and Memory .

| Name       | Description      |   Size (byte) | Starting Address   | Ending Address   | Access   |
|------------|------------------|---------------|--------------------|------------------|----------|
| DS_Y_MEM   | Memory block Y   |           384 | 0x0000             | 0x017F           | WO       |
| DS_M_MEM   | Memory block M   |           384 | 0x0200             | 0x037F           | WO       |
| DS_RB_MEM  | Memory block r   |           384 | 0x0400             | 0x057F           | WO       |
| DS_BOX_MEM | Memory block Box |            48 | 0x0600             | 0x062F           | WO       |
| DS_X_MEM   | Memory block X   |           384 | 0x0800             | 0x097F           | WO       |
| DS_Z_MEM   | Memory block Z   |           384 | 0x0A00             | 0x0B7F           | RO       |

## 22.5 Register Summary

The addresses in this section are relative to Digital Signature base address provided in Table 3.3-3 in Chapter 3 System and Memory .

The abbreviations given in Column Access are explained in Section Access Types for Registers .

| Name                     | Description                                 | Address                  | Access                   |
|--------------------------|---------------------------------------------|--------------------------|--------------------------|
| Configuration Registers  | Configuration Registers                     | Configuration Registers  | Configuration Registers  |
| DS_IV_0_REG              | IV block data                               | 0x0630                   | WO                       |
| DS_IV_1_REG              | IV block data                               | 0x0634                   | WO                       |
| DS_IV_2_REG              | IV block data                               | 0x0638                   | WO                       |
| DS_IV_3_REG              | IV block data                               | 0x063C                   | WO                       |
| Status/Control Registers | Status/Control Registers                    | Status/Control Registers | Status/Control Registers |
| DS_SET_START_REG         | Activates the DS module                     | 0x0E00                   | WO                       |
| DS_SET_ME_REG            | Starts DS operation                         | 0x0E04                   | WO                       |
| DS_SET_FINISH_REG        | Ends DS operation                           | 0x0E08                   | WO                       |
| DS_QUERY_BUSY_REG        | Status of the DS module                     | 0x0E0C                   | RO                       |
| DS_QUERY_KEY_WRONG_REG   | Checks the reason why DS _ KEY is not ready | 0x0E10                   | RO                       |
| DS_QUERY_CHECK_REG       | Queries DS check result                     | 0x0814                   | RO                       |
| Version control register | Version control register                    | Version control register | Version control register |
| DS_DATE_REG              | Version control register                    | 0x0820                   | W/R                      |

## 22.6 Registers

The addresses in this section are relative to Digital Signature base address provided in Table 3.3-3 in Chapter 3 System and Memory .

![Image](images/22_Chapter_22_img003_912ef709.png)

Register 22.2. DS\_SET\_START\_REG (0x0E00)

![Image](images/22_Chapter_22_img004_a7c88e7f.png)

DS\_SET\_START Write 1 to this register to activate the DS peripheral. (WO)

Register 22.3. DS\_SET\_ME\_REG (0x0E04)

![Image](images/22_Chapter_22_img005_1894716c.png)

Register 22.4. DS\_SET\_FINISH\_REG (0x0E08)

![Image](images/22_Chapter_22_img006_1fc63aae.png)

## Register 22.7. DS\_QUERY\_CHECK\_REG (0x0E14)

![Image](images/22_Chapter_22_img007_f71d7bcc.png)

DS\_PADDING\_BAD 1: The padding check fails; 0: The padding check passes. (RO)

DS\_MD\_ERROR 1: The MD check fails; 0: The MD check passes. (RO)

## Register 22.8. DS\_DATE\_REG (0x0E20)

![Image](images/22_Chapter_22_img008_474a4006.png)

DS\_DATE Version control register. (R/W)
