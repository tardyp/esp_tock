# Global Issue Tracker for Tock ESP32-C6 Port
# 
# Rules:
# - Issue IDs are globally unique and NEVER reused
# - Reviewer creates issues; Supervisor ensures PO awareness
# - TechDebt items remain until resolved in a TechDebt PI
#
# Severity: critical, high, medium, low
# Type: bug, techdebt, enhancement, question
# Status: open, in_progress, resolved, wont_fix

next_id: 11

issues:
  - id: 1
    severity: low
    type: techdebt
    title: "Unused FAULT_RESPONSE constant in main.rs"
    status: open
    sprint: PI001/SP001
    created_by: reviewer
    created_at: 2026-02-10
    resolved_at: null
    notes: "Constant FAULT_RESPONSE defined but never used. Either implement process fault handling or remove constant. Not critical for SP001 functionality."
  
  - id: 2
    severity: high
    type: techdebt
    title: "Watchdog disable not implemented"
    status: resolved
    sprint: PI002/SP001
    created_by: reviewer
    created_at: 2026-02-10
    resolved_at: 2026-02-12
    resolved_by: implementor
    verified_by: integrator
    notes: "RESOLVED in PI002/SP001. Implemented watchdog.rs module to disable MWDT0, MWDT1, and RTC WDT. Hardware testing confirmed zero watchdog resets during 65-second stability test. See project_management/PI002_CorePeripherals/SP001_WatchdogClock/ for implementation and test reports."
  
  - id: 3
    severity: medium
    type: techdebt
    title: "Clock configuration not implemented"
    status: resolved
    sprint: PI002/SP001
    created_by: reviewer
    created_at: 2026-02-10
    resolved_at: 2026-02-12
    resolved_by: implementor
    verified_by: integrator
    notes: "RESOLVED in PI002/SP001. Implemented pcr.rs module for peripheral clock and reset management. Configured TIMG0/1 clocks with XTAL source (40 MHz), enabled UART0/1 clocks. Hardware testing confirmed peripheral clocks functional. See project_management/PI002_CorePeripherals/SP001_WatchdogClock/ for implementation and test reports."
  
  - id: 4
    severity: high
    type: techdebt
    title: "INTC driver not implemented - placeholder interrupt handling"
    status: resolved
    sprint: PI002/SP002
    created_by: reviewer
    created_at: 2026-02-10
    resolved_at: 2026-02-12
    resolved_by: implementor
    verified_by: integrator
    notes: "RESOLVED in PI002/SP002. Implemented complete two-stage INTC driver: intmtx.rs (interrupt matrix mapping), intpri.rs (priority and enable control), intc.rs (unified interface). Integrated into chip.rs with proper service_pending_interrupts() and has_pending_interrupts() implementations. Hardware validated successfully - INTC initializes correctly, no spurious interrupts, system stable. See project_management/PI002_CorePeripherals/SP002_INTC/ for implementation and test reports."
  
  - id: 5
    severity: high
    type: techdebt
    title: "PMP disabled - no userspace memory protection"
    status: open
    sprint: PI001/SP003
    created_by: reviewer
    created_at: 2026-02-12
    resolved_at: null
    notes: "chip.rs uses SimplePMP<0> (0 PMP regions) to bypass bootloader-locked entries. This means no userspace memory protection. Acceptable for bring-up but must fix before running untrusted code. Suggested solution: Implement SkipLockedPMP that scans for unlocked entries and uses only those for protection."
  
  - id: 6
    severity: low
    type: techdebt
    title: "Clippy false positive on Writer struct in io.rs"
    status: open
    sprint: PI001/SP003
    created_by: reviewer
    created_at: 2026-02-12
    resolved_at: null
    notes: "boards/nano-esp32-c6/src/io.rs:12-14 - Clippy reports Writer struct and WRITER static as dead_code, but they are used in panic_fmt() via unsafe pointer. Add #[allow(dead_code)] attribute to suppress false positive."
  
  - id: 7
    severity: low
    type: techdebt
    title: "Stale TODO comment in chip.rs handle_interrupt()"
    status: open
    sprint: PI002/SP002
    created_by: reviewer
    created_at: 2026-02-12
    resolved_at: null
    notes: "tock/chips/esp32-c6/src/chip.rs:228 - TODO comment 'Implement interrupt handling with INTC' is stale. INTC is now implemented and integrated into service_pending_interrupts(). The handle_interrupt() function is a low-level trap handler that correctly just re-enables interrupts. Update comment to clarify this is the trap handler, not the dispatch handler, and add reference to service_pending_interrupts()."
  
  - id: 8
    severity: low
    type: enhancement
    title: "GPIO test coverage limited to 5 pins out of 31"
    status: open
    sprint: PI002/SP004
    created_by: reviewer
    created_at: 2026-02-12
    resolved_at: null
    notes: "GPIO test module currently tests only 5 pins (GPIO5, 6, 7, 8, 9) out of 31 available pins. While unit tests verify all 31 pins can be created and accessed, hardware tests only validate a subset. Future enhancement: Add comprehensive pin testing (all 31 pins), automated test fixture with GPIO expander, drive strength configuration tests, simultaneous interrupts on multiple pins. Low priority - unit tests verify all pins are properly defined."
  
  - id: 9
    severity: low
    type: enhancement
    title: "Drive strength configuration not exposed in GPIO API"
    status: open
    sprint: PI002/SP004
    created_by: reviewer
    created_at: 2026-02-12
    resolved_at: null
    notes: "GPIO driver uses IO_MUX default drive strength. The FUN_DRV and MCU_DRV bitfields are defined in register structure but not exposed in public API. Default drive strength suitable for most applications. Future enhancement: Add set_drive_strength() method to Configure trait, define enum for drive strength levels (0-3), document current limits for each level. Defer until specific use case arises."
  
  - id: 10
    severity: low
    type: enhancement
    title: "Open-drain mode not exposed in GPIO API"
    status: open
    sprint: PI002/SP004
    created_by: reviewer
    created_at: 2026-02-12
    resolved_at: null
    notes: "GPIO driver defines PAD_DRIVER bitfield for open-drain mode but does not expose it in public API. Currently only push-pull mode is available. Push-pull mode sufficient for most applications. Open-drain needed for I2C, 1-Wire, and other protocols, but peripheral drivers can configure this directly via IO_MUX. Future enhancement: Add set_output_mode() method if needed for GPIO-based protocols, define enum for OutputMode (PushPull, OpenDrain). Defer until specific use case arises."
